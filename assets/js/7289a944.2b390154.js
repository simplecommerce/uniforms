(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[487],{77058:(e,n,r)=>{"use strict";r.r(n),r.d(n,{frontMatter:()=>o,metadata:()=>s,toc:()=>l,default:()=>m});var a=r(29603),t=r(50120),i=(r(27378),r(35318)),o={id:"examples-custom-bridge",title:"Custom bridge & validator"},s={unversionedId:"examples-custom-bridge",id:"examples-custom-bridge",isDocsHomePage:!1,title:"Custom bridge & validator",description:"In this example, we will create an ordinary login form, with login, password, and password confirmation fields.",source:"@site/../docs/examples-custom-bridge.md",sourceDirName:".",slug:"/examples-custom-bridge",permalink:"/docs/examples-custom-bridge",version:"current",frontMatter:{id:"examples-custom-bridge",title:"Custom bridge & validator"},sidebar:"docs",previous:{title:"Custom fields",permalink:"/docs/examples-custom-fields"},next:{title:"Custom form",permalink:"/docs/examples-custom-form"}},l=[{value:"Schema definition",id:"schema-definition",children:[]},{value:"Validator definition",id:"validator-definition",children:[]},{value:"The Bridge!",id:"the-bridge",children:[]},{value:"Usage",id:"usage",children:[]}],d={toc:l};function m(e){var n=e.components,r=(0,t.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,a.Z)({},d,r,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this example, we will create an ordinary login form, with login, password, and password confirmation fields."),(0,i.kt)("h3",{id:"schema-definition"},"Schema definition"),(0,i.kt)("p",null,"We'll start with defining a schema.\nIt's an object with three keys, representing our fields.\nEach of them has the following self-explanatory properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"__type__")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"required")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"initialValue")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"label"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const UserLoginSchema = {\n  login: {\n    __type__: String,\n    required: true,\n    initialValue: '',\n    label: 'Login'\n  },\n  password1: {\n    __type__: String,\n    required: true,\n    initialValue: '',\n    label: 'Password'\n  },\n  password2: {\n    __type__: String,\n    required: true,\n    initialValue: '',\n    label: 'Password (again)'\n  }\n};\n\nexport default UserLoginSchema;\n")),(0,i.kt)("h3",{id:"validator-definition"},"Validator definition"),(0,i.kt)("p",null,"When the schema is ready, our next step is to provide a way to check if the values received from our form are correct.\nIn order to do so, we prepare a validation function.\nThat function, called validator, takes a model (the submitted object) as input and throws an error whether any value doesn't meet given criteria."),(0,i.kt)("p",null,"In our case we say 'form is invalid' when there's no login or password at all,\nlogin has less then 5 characters, password has lass then 10 characters or given passwords mismatch:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const UserLoginSchemaValidator = model => {\n  const error = {};\n\n  if (!model.login) {\n    error.login = 'Login is required!';\n  } else if (model.login.length < 5) {\n    error.login = 'Login has to be at least 5 characters long!';\n  }\n\n  if (!model.password1) {\n    error.password1 = 'Password is required!';\n  } else if (model.password1.length < 10) {\n    error.login = 'Password has to be at least 10 characters long!';\n  }\n\n  if (model.password1 !== model.password2) {\n    error.password1 = 'Passwords mismatch!';\n  }\n\n  if (Object.keys(error).length) {\n    return error;\n  }\n};\n\nexport default UserLoginSchemaValidator;\n")),(0,i.kt)("h3",{id:"the-bridge"},"The Bridge!"),(0,i.kt)("p",null,"Now that both have the schema and the validator, we can define our bridge, which will be a binder between the form and the data itself.\nAll we have to do is to extend ",(0,i.kt)("inlineCode",{parentName:"p"},"Bridge")," class and implement its methods according to the ",(0,i.kt)("a",{parentName:"p",href:"/docs/uth-bridge-concept"},"Bridge concept"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Bridge } from 'uniforms';\n\nexport default class UserLoginSchemaBridge extends Bridge {\n  constructor(schema, validator) {\n    super();\n\n    this.schema = schema;\n    this.validator = validator;\n  }\n\n  getError(name, error) {\n    return error && error[name];\n  }\n\n  getErrorMessage(name, error) {\n    return (error && error[name]) || '';\n  }\n\n  getErrorMessages(error) {\n    return error ? Object.keys(this.schema).map(field => error[field]) : [];\n  }\n\n  getField(name) {\n    return this.schema[name.replace(/\\.\\d+/g, '.$')];\n  }\n\n  getType(name) {\n    return this.schema[name.replace(/\\.\\d+/g, '.$')].__type__;\n  }\n\n  getProps(name) {\n    return this.schema[name.replace(/\\.\\d+/g, '.$')];\n  }\n\n  getInitialValue(name) {\n    return this.schema[name.replace(/\\.\\d+/g, '.$')].initialValue;\n  }\n\n  getSubfields(name) {\n    return name\n      ? this.schema[name.replace(/\\.\\d+/g, '.$')].subfields || []\n      : Object.keys(this.schema).filter(field => field.indexOf('.') === -1);\n  }\n\n  getValidator() {\n    return this.validator;\n  }\n}\n")),(0,i.kt)("h3",{id:"usage"},"Usage"),(0,i.kt)("p",null,"After our custom bridge is created, we can use in the very same way as we would use predefined one -\nwe have to supply the schema and validator and then we can take an advantage of it in the AutoForm:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import UserLoginSchema from './UserLoginSchema';\nimport UserLoginSchemaBridge from './UserLoginSchemaBridge';\nimport UserLoginSchemaValidator from './UserLoginSchemaValidator';\n\nconst bridge = new UserLoginSchemaBridge(\n  UserLoginSchema,\n  UserLoginSchemaValidator\n);\n\n<AutoForm schema={bridge} />;\n")))}m.isMDXComponent=!0}}]);