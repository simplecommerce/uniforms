(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[529],{83290:(e,t,a)=>{"use strict";a.r(t),a.d(t,{frontMatter:()=>r,metadata:()=>l,toc:()=>s,default:()=>p});var n=a(29603),o=a(50120),i=(a(27378),a(35318)),r={id:"faq",title:"FAQ"},l={unversionedId:"faq",id:"faq",isDocsHomePage:!1,title:"FAQ",description:"How can I customize/style my form fields?",source:"@site/../docs/faq.md",sourceDirName:".",slug:"/faq",permalink:"/docs/faq",version:"current",frontMatter:{id:"faq",title:"FAQ"},sidebar:"docs",previous:{title:"Installation",permalink:"/docs/installation"},next:{title:"Migrating v2 to v3",permalink:"/docs/migrating-2-to-3"}},s=[{value:"How can I customize/style my form fields?",id:"how-can-i-customizestyle-my-form-fields",children:[]},{value:"How can I create custom fields?",id:"how-can-i-create-custom-fields",children:[]},{value:"How can I use a custom field in my form?",id:"how-can-i-use-a-custom-field-in-my-form",children:[]},{value:"How can I pass additional props to the custom field?",id:"how-can-i-pass-additional-props-to-the-custom-field",children:[]},{value:"How can I have a dynamic label? (e.g. handling i18n)",id:"how-can-i-have-a-dynamic-label-eg-handling-i18n",children:[]},{value:"How can I change the way my form validates?",id:"how-can-i-change-the-way-my-form-validates",children:[]},{value:"How can I reset my form state?",id:"how-can-i-reset-my-form-state",children:[]},{value:"I want my form to be prefilled with data. How can I do that?",id:"i-want-my-form-to-be-prefilled-with-data-how-can-i-do-that",children:[]},{value:"How can I transform my model?",id:"how-can-i-transform-my-model",children:[]},{value:"How can I make my form autofocused?",id:"how-can-i-make-my-form-autofocused",children:[]},{value:"How can I create a multi-step form?",id:"how-can-i-create-a-multi-step-form",children:[]},{value:"How can I know a current form state?",id:"how-can-i-know-a-current-form-state",children:[]},{value:"I want to disable a submit button until there is a difference between the current form state and my model. How can I do it?",id:"i-want-to-disable-a-submit-button-until-there-is-a-difference-between-the-current-form-state-and-my-model-how-can-i-do-it",children:[]}],m={toc:s};function p(e){var t=e.components,a=(0,o.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"how-can-i-customizestyle-my-form-fields"},"How can I customize/style my form fields?"),(0,i.kt)("p",null,"You can style your form fields simply by passing a ",(0,i.kt)("inlineCode",{parentName:"p"},"className")," property."),(0,i.kt)("h3",{id:"how-can-i-create-custom-fields"},"How can I create custom fields?"),(0,i.kt)("p",null,"You can create a custom field by wrapping your component inside the ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-helpers#connectfieldcomponent-options"},(0,i.kt)("inlineCode",{parentName:"a"},"connectField")),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"connectField")," will pass various props related to the form management, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"onChange()")," function, current field's value, errors and so on, to your component."),(0,i.kt)("p",null,"Please visit the ",(0,i.kt)("a",{parentName:"p",href:"/docs/tutorials-creating-custom-field"},"Tutorials > Creating a custom field")," tutorial to see how to create your own fields."),(0,i.kt)("h3",{id:"how-can-i-use-a-custom-field-in-my-form"},"How can I use a custom field in my form?"),(0,i.kt)("p",null,"You can tell your schema to use your custom field by adding the ",(0,i.kt)("inlineCode",{parentName:"p"},"uniforms")," property."),(0,i.kt)("p",null,"Example in JSONSchema:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const schema = {\n  /*...*/\n  firstName: {\n    type: 'string',\n    uniforms: MyCustomFirstNameField\n  }\n  /*...*/\n};\n")),(0,i.kt)("p",null,"We say that the component used for the ",(0,i.kt)("inlineCode",{parentName:"p"},"firstName")," property will be the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyCustomFirstNameField"),"."),(0,i.kt)("p",null,"You can also leave the schema untouched and pass your custom field directly to the ",(0,i.kt)("inlineCode",{parentName:"p"},"AutoField")," in a ",(0,i.kt)("inlineCode",{parentName:"p"},"component")," property instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'<AutoForm schema={schema} onSubmit={onSubmit}>\n  /*...*/\n  <AutoField component={MyCustomFirstNameField} name="firstName" />\n  /*...*/\n</AutoForm>\n')),(0,i.kt)("h3",{id:"how-can-i-pass-additional-props-to-the-custom-field"},"How can I pass additional props to the custom field?"),(0,i.kt)("p",null,"You can pass any additional props to your custom field, by converting the ",(0,i.kt)("inlineCode",{parentName:"p"},"uniforms")," property to the type of object, with the ",(0,i.kt)("inlineCode",{parentName:"p"},"component")," key. Any other keys will be treated as props."),(0,i.kt)("p",null,"E.g. in JSONSchema:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const schema = {\n  /*...*/\n  firstName: {\n    type: 'string',\n    uniforms: {\n      component: MyCustomFirstNameField,\n      propA: 1,\n      propB: 2\n    }\n  }\n  /*...*/\n};\n")),(0,i.kt)("p",null,"We say that the component used for the ",(0,i.kt)("inlineCode",{parentName:"p"},"firstName")," property will be the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyCustomFirstNameField")," and it will receive 2 additonal props: ",(0,i.kt)("inlineCode",{parentName:"p"},"propA")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"propB"),"."),(0,i.kt)("p",null,"You can also leave the schema untouched and pass your custom field with props directly to the ",(0,i.kt)("inlineCode",{parentName:"p"},"AutoField")," instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'<AutoForm schema={schema} onSubmit={onSubmit}>\n  /*...*/\n  <AutoField\n    component={MyCustomFirstNameField}\n    name="firstName"\n    propA={1}\n    propB={2}\n  />\n  /*...*/\n</AutoForm>\n')),(0,i.kt)("h3",{id:"how-can-i-have-a-dynamic-label-eg-handling-i18n"},"How can I have a dynamic label? (e.g. handling i18n)"),(0,i.kt)("p",null,"There are few ways to handle that, depending on the level of abstraction you want to do it - schema, field or ",(0,i.kt)("inlineCode",{parentName:"p"},"AutoField")," component."),(0,i.kt)("p",null,"On the ",(0,i.kt)("strong",{parentName:"p"},"schema")," level, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"uniforms: {...}")," object property to pass extra props to the field.\nA function returning it (",(0,i.kt)("inlineCode",{parentName:"p"},"uniforms: () => ({...})"),") is also accepted. With it, dynamic labels can be fetched from any source."),(0,i.kt)("p",null,"On the ",(0,i.kt)("strong",{parentName:"p"},"field")," level, you can prepare your own component set, where you will use ",(0,i.kt)("inlineCode",{parentName:"p"},"<Translate>{label}</Translate>")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"{label}"),"."),(0,i.kt)("p",null,"While the first one is schema-dependent and the second is theme-dependent, there's an additional option, somewhere in between. You can create a custom ",(0,i.kt)("inlineCode",{parentName:"p"},"AutoField")," component, based on a builtin one, where you provide some additional props and label might be one of them (based on other props, like name or some schema field)."),(0,i.kt)("h3",{id:"how-can-i-change-the-way-my-form-validates"},"How can I change the way my form validates?"),(0,i.kt)("p",null,"Any form can be validated in one of those three styles:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"onChange"),"\nValidate on every change.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"onChangeAfterSubmit")," ",(0,i.kt)("em",{parentName:"p"},"(default)"),"\nValidate on every change, but only after first submit.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"onSubmit"),"\nValidate on every submit."))),(0,i.kt)("p",null,"You change the way your form validates by setting ",(0,i.kt)("inlineCode",{parentName:"p"},"validate")," prop:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'<AutoForm validate="onChange" schema={schema} onSubmit={onSubmit} />\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," If your schema validator accepts any options, those can be passed in ",(0,i.kt)("inlineCode",{parentName:"p"},"validator")," prop:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"<AutoForm validator={validatorOptions} />\n")),(0,i.kt)("h3",{id:"how-can-i-reset-my-form-state"},"How can I reset my form state?"),(0,i.kt)("p",null,"You can use ",(0,i.kt)("a",{parentName:"p",href:"https://facebook.github.io/react/docs/more-about-refs.html"},"React ",(0,i.kt)("inlineCode",{parentName:"a"},"ref")," prop")," to manually access form methods."),(0,i.kt)("p",null,"These methods are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"change(key, value)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reset()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"submit()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"validate()")," ",(0,i.kt)("em",{parentName:"li"},"(added in ",(0,i.kt)("inlineCode",{parentName:"em"},"ValidatedForm"),")"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const MyForm = ({ schema, onSubmit }) => {\n  let formRef;\n\n  return (\n    <section>\n      <AutoForm\n        ref={ref => (formRef = ref)}\n        schema={schema}\n        onSubmit={onSubmit}\n      />\n      <small onClick={() => formRef.reset()}>Reset</small>\n      <small onClick={() => formRef.submit()}>Submit</small>\n    </section>\n  );\n};\n")),(0,i.kt)("p",null,"You can find more about form methods ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-forms"},"here"),"."),(0,i.kt)("h3",{id:"i-want-my-form-to-be-prefilled-with-data-how-can-i-do-that"},"I want my form to be prefilled with data. How can I do that?"),(0,i.kt)("p",null,"You can pass the initial data to the form by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"model")," prop."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"model")," is an object with ",(0,i.kt)("inlineCode",{parentName:"p"},"{field: value}")," structure. It doesn't matter if it has a prototype or not, but keep in mind that in ",(0,i.kt)("inlineCode",{parentName:"p"},"onSubmit")," or in ",(0,i.kt)("inlineCode",{parentName:"p"},"onChangeModel")," you'll receive a plain object. If you treat form as an input, then this is a value."),(0,i.kt)("h3",{id:"how-can-i-transform-my-model"},"How can I transform my model?"),(0,i.kt)("p",null,"You should ",(0,i.kt)("inlineCode",{parentName:"p"},"modelTransform"),". It is a function transforming one model into another. It's used in a few situations (called 'modes') described below."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Remember not to mutate a given model!")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"function transform(mode, model) {\n  // This model will be passed to the fields.\n  if (mode === 'form') {\n    /* ... */\n  }\n\n  // This model will be submitted.\n  if (mode === 'submit') {\n    /* ... */\n  }\n\n  // This model will be validated.\n  if (mode === 'validate') {\n    /* ... */\n  }\n\n  // Otherwise, return unaltered model.\n  return model;\n}\n\n<AutoForm modelTransform={transform} schema={schema} onSubmit={onSubmit} />;\n")),(0,i.kt)("h3",{id:"how-can-i-make-my-form-autofocused"},"How can I make my form autofocused?"),(0,i.kt)("p",null,"You can take a reference to the field and manually trigger ",(0,i.kt)("inlineCode",{parentName:"p"},".focus()"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'<AutoField name="firstName" inputRef={field => field.focus()} />\n')),(0,i.kt)("h3",{id:"how-can-i-create-a-multi-step-form"},"How can I create a multi-step form?"),(0,i.kt)("p",null,"What is a multi-step form? Well, one can imagine at least two completely separate definitions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"A set of independent forms with a shared state.")," That's the ",(0,i.kt)("em",{parentName:"p"},"easier")," one as it's always possible. Each step renders a separate form, with a different schema/validator/style and moves to the next one when submitted, accumulating submitted data."),(0,i.kt)("p",{parentName:"li"},"This handles not only multi-step forms but also ",(0,i.kt)("s",null,"forms")," wizards with a tree-like structure (i.e. next step bases on the answers). Optional steps (",(0,i.kt)("em",{parentName:"p"},"skip step 2 if age < 40"),") and contextual validation (",(0,i.kt)("em",{parentName:"p"},"field Y in step 2 has to be greater than the value of X in step 1"),") is also possible."),(0,i.kt)("p",{parentName:"li"},"But it gets even better - each step may use a different forms library! It makes no sense but is definitely possible - each form is independent, and the orchestration happens in the application.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"A single form displayed in parts.")," It is, of course, possible to implement it, but the number of all configurations and options is ",(0,i.kt)("em",{parentName:"p"},"massive"),". But let's skip that and see where a bigger problem is: the validation. In ",(0,i.kt)("strong",{parentName:"p"},"1.")," each step is validated separately (i.e. can have a separate schema). Here, we have only one schema, and the schema itself has to know that ",(0,i.kt)("em",{parentName:"p"},"some")," fields were not yet visible."),(0,i.kt)("p",{parentName:"li"},"Let's make an example. The schema is very basic: ",(0,i.kt)("inlineCode",{parentName:"p"},"{ a: string, b: string }")," (TypeScript notation). Now, as both ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," are required, a ",(0,i.kt)("em",{parentName:"p"},"valid")," model has to have both. If the first step will render only the ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," field (",(0,i.kt)("inlineCode",{parentName:"p"},"b")," is on the next page), it's impossible to validate the form. This leads to a situation where the schema (logic) depends on the steps (UI). On the other hand, the form could be validated only at the end. The UX of this solution is terrible though - imagine a ",(0,i.kt)("em",{parentName:"p"},"there's an error ten pages back")," error!"))),(0,i.kt)("p",null,"We are not planning to provide any out-of-the-box support for multi-step forms as option ",(0,i.kt)("strong",{parentName:"p"},"1.")," is most of the time the best. It's not only the cleanest but also less complicated as well as doesn't rely on any library."),(0,i.kt)("h3",{id:"how-can-i-know-a-current-form-state"},"How can I know a current form state?"),(0,i.kt)("p",null,"A current form state is available in ",(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/context.html"},"React context"),", accessible through ",(0,i.kt)("inlineCode",{parentName:"p"},"useForm")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"useField(name)")," hooks."),(0,i.kt)("p",null,"The context data consists of various properties which can be found in ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-context-data"},"here"),"."),(0,i.kt)("h5",{id:"example-usage"},"Example usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"function SubmittingState() {\n  const uniforms = useForm();\n  return uniforms.submitting ? 'Submitting...' : null;\n}\n\n<AutoForm>\n  <SubmittingState />\n</AutoForm>;\n")),(0,i.kt)("h3",{id:"i-want-to-disable-a-submit-button-until-there-is-a-difference-between-the-current-form-state-and-my-model-how-can-i-do-it"},"I want to disable a submit button until there is a difference between the current form state and my model. How can I do it?"),(0,i.kt)("p",null,"Basically, you have to find out whether there is a difference between a current form state and your model, e.g. by calling lodash's ",(0,i.kt)("inlineCode",{parentName:"p"},"isEqual")," function.\nCurrent form state can be accessed through the context (see ",(0,i.kt)("a",{parentName:"p",href:"/docs/faq#how-can-i-know-a-current-form-state"},"How can I know a current form state?"),") and form model can be passed as an ordinary prop:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"function DifferentSubmitField({ initialModel }) {\n  const { model } = useForm();\n  return <SubmitField disabled={isEqual(uniforms.model, initialModel)} />;\n}\n\nconst ChangedForm = ({ model }) => (\n  <AutoForm model={model}>\n    <DifferentSubmitField initialModel={model} />\n  </AutoForm>\n);\n")))}p.isMDXComponent=!0}}]);