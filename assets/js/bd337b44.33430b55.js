(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[442],{57292:(e,n,r)=>{"use strict";r.d(n,{f:()=>i});var t=r(77356),a=r(27378);function i(e){var n=e.language,r=e.replace,i=e.section,o=e.source;if("object"==typeof o&&"default"in o&&(o=o.default),i){var s=new RegExp("// <"+i+">\\s([\\s\\S]*?)\\s// </"+i+">\\s","g");o=o.split(s).reduce((function(e,n,r){return r%2==0?e:e+"\n\n"+n}),"")}if(o=o.replace(/\/\/ <.*?\n/g,""),r)for(var d=0,l=Object.entries(r);d<l.length;d++){var m=l[d],c=m[0],p=m[1];o=o.replace(new RegExp(c,"gs"),p)}return(o=o.trim()).includes("\n")||(o+="\n"),a.createElement(t.Z.pre,null,a.createElement(t.Z.code,{children:o,className:"language-"+n,mdxType:"code",originalType:"code",parentName:"pre"}))}},59356:(e,n,r)=>{"use strict";r.r(n),r.d(n,{frontMatter:()=>s,metadata:()=>d,toc:()=>l,default:()=>c});var t=r(29603),a=r(50120),i=(r(27378),r(35318)),o=r(57292),s={id:"uth-bridge-concept",title:"Bridge concept"},d={unversionedId:"uth-bridge-concept",id:"uth-bridge-concept",isDocsHomePage:!1,title:"Bridge concept",description:'To make use of any schema, uniforms have to create a bridge of it - a unified schema mapper. The Bridge class is an abstract class, which should be extended to create custom bridges. It implements all of the required methods and throws an error with meaningful "method not implemented" error.',source:"@site/../docs/uth-bridge-concept.mdx",sourceDirName:".",slug:"/uth-bridge-concept",permalink:"/docs/uth-bridge-concept",version:"current",frontMatter:{id:"uth-bridge-concept",title:"Bridge concept"},sidebar:"docs",previous:{title:"AutoField algorithm",permalink:"/docs/uth-autofield-algorithm"}},l=[],m={toc:l};function c(e){var n=e.components,s=(0,a.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,t.Z)({},m,s,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"To make use of any schema, uniforms have to create a ",(0,i.kt)("em",{parentName:"p"},"bridge")," of it - a unified schema mapper. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Bridge"),' class is an abstract class, which should be extended to create custom bridges. It implements all of the required methods and throws an error with meaningful "method not implemented" error.'),(0,i.kt)(o.f,{language:"tsx",replace:{"(  .*?) {\n.*?  }":"$1;","(import |  // eslint).*?\n":""},source:r(75079),mdxType:"CodeSection"}))}c.isMDXComponent=!0},75079:(e,n,r)=>{"use strict";r.r(n),r.d(n,{default:()=>t});const t="import invariant from 'invariant';\n\n// There is no standarized error format. While creating a custom bridge, one can\n// come up with an own error format, returned from validator and later analyzed\n// in `getError*` methods.\ntype Error = any;\n\n// There is no standarized field format. Most bridges use it as a common object,\n// used in calculation of initial values, props, and types.\ntype Field = any;\n\n// There is no standarized field type format. However, `AutoField` component\n// will work correctly only with standard JavaScript constructors, like `String`\n// or `Number`.\ntype FieldType = any;\n\nexport abstract class Bridge {\n  // Each bridge can have a different set of parameters.\n  constructor(...args: any[]) {\n    invariant(\n      this.constructor !== Bridge,\n      'Bridge cannot be instantiated (args=%o).',\n      { args },\n    );\n  }\n\n  // Get an error for field `name` out of `error`. There is no standarized\n  // format, but fields treat truthy values as a sign of being invalid. Fields\n  // receive this as a `error` guaranteed prop.\n  getError(name: string, error: Error): Error {\n    return invariant(\n      false,\n      '%s have not implemented `getError` method (args=%o).',\n      this.constructor.name,\n      { name, error },\n    );\n  }\n\n  // Get an error message for field `name` out of `error`. If there is no error,\n  // return an empty string. Fields receive this as a `errorMessage` guaranteed\n  // prop.\n  getErrorMessage(name: string, error: Error): string {\n    return invariant(\n      false,\n      '%s have not implemented `getErrorMessage` method (args=%o).',\n      this.constructor.name,\n      { name, error },\n    );\n  }\n\n  // Get all error messages from `error`. Only `ErrorsField` make use of that\n  // (in builtin themes).\n  getErrorMessages(error: Error): string[] {\n    return invariant(\n      false,\n      '%s have not implemented `getErrorMessages` method (args=%o).',\n      this.constructor.name,\n      { error },\n    );\n  }\n\n  // Get internal field definition for field `name`. Fields receive this as a\n  // `field` guaranteed prop.\n  getField(name: string): Field {\n    return invariant(\n      false,\n      '%s have not implemented `getField` method (args=%o).',\n      this.constructor.name,\n      { name },\n    );\n  }\n\n  // Get initial value of field `name`. It is used as a default when no value is\n  // set (e.g. the form is rendered with an empty `model`). Additionally,\n  // `props` are this field instance props. If a field is rendered multiple\n  // times, this function will be called multiple times, possibly with different\n  // `props`.\n  getInitialValue(name: string, props: Record<string, any>): any {\n    return invariant(\n      false,\n      '%s have not implemented `getInitialValue` method (args=%o).',\n      this.constructor.name,\n      { name, props },\n    );\n  }\n\n  // Get props defined in schema for a field `name`. There are no required nor\n  // banned fields, however properties like `required` are often available.\n  // Additionally, `props` are this field instance props. If a field is rendered\n  // multiple times, this function will be called multiple times, possibly with\n  // different `props`.\n  getProps(name: string, props: Record<string, any>): Record<string, any> {\n    return invariant(\n      false,\n      '%s have not implemented `getProps` method (args=%o).',\n      this.constructor.name,\n      { name, props },\n    );\n  }\n\n  // Get a list of subfields of field `name` or top-level fields, if no `name`\n  // is passed.\n  getSubfields(name?: string): string[] {\n    return invariant(\n      false,\n      '%s have not implemented `getSubfields` method (args=%o).',\n      this.constructor.name,\n      { name },\n    );\n  }\n\n  // Get a type of field `name`. See `FieldTypeType` for details.\n  getType(name: string): FieldType {\n    return invariant(\n      false,\n      '%s have not implemented `getType` method (args=%o).',\n      this.constructor.name,\n      { name },\n    );\n  }\n\n  // Get a validator function. The `options` here are from the `validator` prop\n  // of the form. A validator function receives a model and returns an error or\n  // a promise that will resolve (not reject!) with an error. If there is no\n  // error, return (or resolve with) a `null` value instead.\n  // eslint-disable-next-line prettier/prettier\n  getValidator(options?: any): (model: Record<string, any>) => null | Error | Promise<null | Error> {\n    return invariant(\n      false,\n      '%s have not implemented `getValidator` method (args=%o).',\n      this.constructor.name,\n      { options },\n    );\n  }\n}\n"}}]);